package gemini

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/korjavin/ebayDraftListing/pkg/models"
)

const (
	geminiAPIURL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent"
)

// Client handles interactions with the Gemini API
type Client struct {
	apiKey string
	prompt string
}

// NewClient creates a new Gemini API client
func NewClient(apiKey, prompt string) *Client {
	return &Client{
		apiKey: apiKey,
		prompt: prompt,
	}
}

type geminiRequest struct {
	Contents []content `json:"contents"`
}

type content struct {
	Parts []part `json:"parts"`
}

type part struct {
	Text       string      `json:"text,omitempty"`
	InlineData *inlineData `json:"inlineData,omitempty"`
}

type inlineData struct {
	MimeType string `json:"mimeType"`
	Data     string `json:"data"`
}

type geminiResponse struct {
	Candidates []candidate `json:"candidates"`
}

type candidate struct {
	Content contentResponse `json:"content"`
}

type contentResponse struct {
	Parts []partResponse `json:"parts"`
}

type partResponse struct {
	Text string `json:"text"`
}

// GenerateListingContent generates title and description from photos
func (c *Client) GenerateListingContent(photoPaths []string) (*models.ListingContent, error) {
	// Build request with prompt and images
	parts := []part{
		{Text: c.prompt},
	}

	// Add each photo as inline data
	for _, photoPath := range photoPaths {
		imageData, mimeType, err := c.encodeImage(photoPath)
		if err != nil {
			return nil, fmt.Errorf("failed to encode image %s: %w", photoPath, err)
		}

		parts = append(parts, part{
			InlineData: &inlineData{
				MimeType: mimeType,
				Data:     imageData,
			},
		})
	}

	reqBody := geminiRequest{
		Contents: []content{
			{Parts: parts},
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Make API request with exponential backoff retry for 429 errors
	url := fmt.Sprintf("%s?key=%s", geminiAPIURL, c.apiKey)
	maxRetries := 5
	var resp *http.Response
	var body []byte

	for attempt := 0; attempt < maxRetries; attempt++ {
		resp, err = http.Post(url, "application/json", bytes.NewBuffer(jsonData))
		if err != nil {
			return nil, fmt.Errorf("failed to make API request: %w", err)
		}

		body, err = io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			return nil, fmt.Errorf("failed to read response: %w", err)
		}

		// If successful or non-retryable error, break
		if resp.StatusCode == http.StatusOK {
			break
		}

		// Only retry on 429 (rate limit)
		if resp.StatusCode != http.StatusTooManyRequests {
			return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
		}

		// If this was the last attempt, return error
		if attempt == maxRetries-1 {
			return nil, fmt.Errorf("API request failed after %d retries with status %d: %s", maxRetries, resp.StatusCode, string(body))
		}

		// Exponential backoff: 1s, 2s, 4s, 8s, 16s
		backoff := time.Duration(1<<uint(attempt)) * time.Second
		fmt.Printf("Rate limited (429), retrying in %v... (attempt %d/%d)\n", backoff, attempt+1, maxRetries)
		time.Sleep(backoff)
	}

	// Parse response
	var geminiResp geminiResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	if len(geminiResp.Candidates) == 0 || len(geminiResp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content generated by Gemini")
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text

	// Parse the generated text to extract title and description
	return c.parseGeneratedContent(generatedText)
}

// encodeImage reads and base64 encodes an image file
func (c *Client) encodeImage(path string) (string, string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", "", err
	}

	encoded := base64.StdEncoding.EncodeToString(data)

	// Determine MIME type from extension
	mimeType := "image/jpeg"
	ext := filepath.Ext(path)
	switch ext {
	case ".png":
		mimeType = "image/png"
	case ".jpg", ".jpeg":
		mimeType = "image/jpeg"
	case ".gif":
		mimeType = "image/gif"
	case ".webp":
		mimeType = "image/webp"
	}

	return encoded, mimeType, nil
}

// parseGeneratedContent extracts title and description from generated text
func (c *Client) parseGeneratedContent(text string) (*models.ListingContent, error) {
	// Try to parse as JSON first
	var content models.ListingContent
	if err := json.Unmarshal([]byte(text), &content); err == nil {
		return &content, nil
	}

	// If not JSON, try to parse structured text
	// Look for Title: and Description: markers
	lines := bytes.Split([]byte(text), []byte("\n"))
	var title, description string
	var inDescription bool

	for _, line := range lines {
		lineStr := string(bytes.TrimSpace(line))
		if bytes.HasPrefix(bytes.TrimSpace(line), []byte("Title:")) {
			title = string(bytes.TrimSpace(bytes.TrimPrefix(bytes.TrimSpace(line), []byte("Title:"))))
		} else if bytes.HasPrefix(bytes.TrimSpace(line), []byte("Description:")) {
			description = string(bytes.TrimSpace(bytes.TrimPrefix(bytes.TrimSpace(line), []byte("Description:"))))
			inDescription = true
		} else if inDescription && lineStr != "" {
			description += "\n" + lineStr
		}
	}

	if title == "" || description == "" {
		// Fallback: use the entire text as description with a generic title
		return &models.ListingContent{
			Title:       "eBay Listing",
			Description: text,
		}, nil
	}

	return &models.ListingContent{
		Title:       title,
		Description: description,
	}, nil
}
